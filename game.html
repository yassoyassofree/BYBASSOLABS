<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Space Shooter Puzzle Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; font-family: 'Arial', sans-serif; color: #00ff41; overflow: hidden; height: 100vh; }
        .login-check { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; justify-content: center; align-items: center; z-index: 9999; flex-direction: column; gap: 20px; }
        .login-check.hidden { display: none; }
        .login-required { background: rgba(0,255,65,0.1); border: 2px solid #00ff41; padding: 30px; border-radius: 10px; text-align: center; }
        .btn { background: #00ff41; color: #000; border: none; padding: 10px 20px; font-size: 16px; cursor: pointer; border-radius: 5px; font-weight: bold; margin: 5px; }
        .btn:hover { background: #00cc33; }
        .btn.secondary { background: #444; color: #fff; }
        .btn.secondary:hover { background: #666; }
        .btn-small { padding: 6px 12px; font-size: 12px; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        canvas { display: block; margin: 0 auto; background: #000; border: 2px solid #00ff41; }
        .game-container { position: relative; width: 100%; height: 100vh; }
        .hud { position: absolute; top: 10px; left: 10px; font-size: 14px; background: rgba(0,0,0,0.8); padding: 12px; border: 1px solid #00ff41; border-radius: 5px; z-index: 100; }
        .hud div { margin: 3px 0; }
        .top-right { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); padding: 12px; border: 1px solid #00ff41; border-radius: 5px; text-align: right; font-size: 12px; z-index: 100; }
        .btn-group { display:flex; gap: 8px; margin-top:8px; flex-wrap:wrap; }
        .modal { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.9); display:none; justify-content:center; align-items:center; z-index:2000; }
        .modal.active{ display:flex; }
        .modal-content { background: #0a0a2e; border: 2px solid #00ff41; border-radius: 10px; padding: 25px; max-width: 900px; max-height: 80vh; overflow-y: auto; color: #00ff41; }
        .shop-item { background: rgba(0,255,65,0.1); border: 1px solid #00ff41; padding: 10px; margin: 8px 0; border-radius: 5px; display:flex; justify-content:space-between; align-items:center; }
        .shop-item-info { flex:1; }
        .shop-item-name { font-weight:bold; }
        .shop-item-desc { font-size:11px; color:#00aa30; margin:3px 0; }
        .close-btn { background:#ff0000; color:#fff; border:none; padding:8px 15px; font-size:14px; cursor:pointer; border-radius:5px; margin-top:15px; }
        .game-over{ position:fixed; top:50%; left:50%; transform: translate(-50%,-50%); text-align:center; background: rgba(0,0,0,0.95); border:3px solid #ff0000; padding:40px; border-radius:10px; display:none; z-index:1500; }
        .game-over.active{ display:block; }
        .status-msg{ position: fixed; bottom:20px; right:20px; background:#00ff41; color:#000; padding:10px 15px; border-radius:5px; display:none; font-weight:bold; z-index:200; }
        .status-msg.show { display:block; }
        table { width:100%; border-collapse:collapse; margin:15px 0; }
        table th { background:rgba(0,255,65,0.2); border-bottom:2px solid #00ff41; padding:12px; text-align:left; font-weight:bold; }
        table td { padding:10px; border-bottom:1px solid rgba(0,255,65,0.3); }
        .rank-1 { color: #ffd700; font-weight: bold; font-size:18px; }
        .rank-2 { color: #c0c0c0; font-weight: bold; font-size:16px; }
        .rank-3 { color: #cd7f32; font-weight: bold; font-size:14px; }
        .boss-warning { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255,0,0,0.9); border: 3px solid #ff0000; padding: 30px; border-radius: 10px; font-size: 32px; font-weight: bold; color: #fff; z-index: 1000; display: none; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.1); } }
        .level-btn { background: rgba(0,255,65,0.2); border: 2px solid #00ff41; color: #00ff41; padding: 15px; border-radius: 8px; cursor: pointer; font-weight: bold; transition: 0.3s; text-align: center; }
        .level-btn:hover { background: rgba(0,255,65,0.4); transform: scale(1.05); }
        .level-btn.locked { background: rgba(100,100,100,0.2); border-color: #666; color: #666; cursor: not-allowed; }
        .level-btn.locked:hover { transform: none; }
        .level-btn.current { border-color: #ffff00; color: #ffff00; background: rgba(255,255,0,0.2); }
        .level-btn.boss { border-color: #ff00ff; color: #ff00ff; background: rgba(255,0,255,0.2); }
        .lucky-box { width: 100px; height: 100px; background: linear-gradient(45deg, #ffd700, #ff8c00); border: 3px solid #fff; border-radius: 10px; margin: 20px auto; animation: rotate 2s infinite linear; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 48px; }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .puzzle-info { background: rgba(0,255,65,0.1); border: 1px solid #00ff41; padding: 15px; margin: 10px 0; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="login-check" id="loginCheck">
        <div style="text-align:center;">
            <h1>[ SPACE SHOOTER PUZZLE ]</h1>
            <p style="color:#888;">Loading...</p>
        </div>
    </div>

    <div class="login-check hidden" id="loginRequired">
        <div class="login-required">
            <h2>üéÆ ENTER USERNAME</h2>
            <p style="color:#ccc; margin-bottom: 20px;">Choose your player name</p>
            <input id="usernameInput" placeholder="username" style="padding:10px; border-radius:5px; border:1px solid #00ff41; background:#111; color:#00ff41; font-size:16px; width:250px;">
            <div style="margin-top:15px;">
                <button class="btn" onclick="doLogin()">üöÄ START GAME</button>
            </div>
        </div>
    </div>

    <div class="game-container" id="gameContainer" style="display:none;">
        <div class="hud">
            <div>üë§ Player: <span id="username">---</span></div>
            <div>üéØ Level: <span id="level">1</span> / <span id="maxLevel">1</span></div>
            <div>üí∞ Money: <span id="money">0</span></div>
            <div>üèÜ Score: <span id="score">0</span></div>
            <div>‚ù§Ô∏è HP: <span id="hp">100</span></div>
            <div style="margin-top:8px; font-size:11px; color:#00aa30;">üöÄ Ship: <span id="shipname">Classic</span></div>
            <div style="font-size:11px; color:#00aa30;">‚öîÔ∏è Damage: <span id="damage">1</span>x</div>
            <div style="font-size:11px; color:#ffff00;">üìä Puzzle: <span id="puzzleType">---</span></div>
            <div style="font-size:11px; color:#ffff00;">üéØ Goal: <span id="puzzleGoal">---</span></div>
        </div>

        <div class="top-right">
            <div>üëæ Enemies: <span id="enemies-count">0</span></div>
            <div class="btn-group">
                <button class="btn btn-small" onclick="openLevelSelect()">üìã Levels</button>
                <button class="btn btn-small" onclick="openShop()">üõí Shop</button>
                <button class="btn btn-small" onclick="openLeaderboard()">üèÜ Leaderboard</button>
                <button class="btn btn-small" id="adminBtn" style="display:none;" onclick="openAdmin()">‚öôÔ∏è Admin</button>
                <button class="btn btn-small" onclick="logout()">üö™ Exit</button>
                <button class="btn btn-small" onclick="openTrading()">ü§ù Trade</button>
            </div>
        </div>

        <canvas id="gameCanvas" width="1000" height="600"></canvas>

        <div class="boss-warning" id="bossWarning">‚ö†Ô∏è BOSS LEVEL ‚ö†Ô∏è</div>

        <div class="modal" id="levelSelectModal">
            <div class="modal-content">
                <h2>üìã [ LEVEL SELECT - 150 PUZZLES ]</h2>
                <div id="levelSelectContent" style="max-height:500px; overflow-y:auto; display:grid; grid-template-columns:repeat(auto-fill, minmax(80px, 1fr)); gap:10px; padding:10px;"></div>
                <button class="close-btn" onclick="closeLevelSelect()" style="width:100%;">CLOSE</button>
            </div>
        </div>

        <div class="modal" id="luckyBoxModal">
            <div class="modal-content" style="text-align:center;">
                <h2>üéÅ [ LUCKY BOX! ]</h2>
                <div id="luckyBoxContent"></div>
                <button class="close-btn" onclick="closeLuckyBox()">COLLECT & CLOSE</button>
            </div>
        </div>

        <div class="modal" id="shopModal">
            <div class="modal-content">
                <h2>üõí [ SHOP ]</h2>
                <div id="shopItems"></div>
                <button class="close-btn" onclick="closeShop()">Close & Resume</button>
            </div>
        </div>

        <div class="modal" id="leaderboardModal">
            <div class="modal-content">
                <h2>üèÜ [ TOP PLAYERS LEADERBOARD ]</h2>
                <div id="leaderboardContent" style="max-height:500px; overflow-y:auto;"></div>
                <button class="close-btn" onclick="closeLeaderboard()" style="width:100%;">CLOSE</button>
            </div>
        </div>

        <div class="modal" id="adminModal">
            <div class="modal-content">
                <h2>‚öôÔ∏è [ ADMIN PANEL ]</h2>
                <div id="adminOutput" style="background: rgba(0,0,0,0.7); border: 1px solid #00ff41; padding: 10px; margin-bottom: 10px; height: 300px; overflow-y: auto; font-size: 11px; font-family: monospace;"></div>
                <div style="display:flex; gap:8px;">
                    <input type="text" id="adminInput" placeholder="Enter command..." style="flex:1; background:#1a1a1a; border:1px solid #00ff41; color:#00ff41; padding:8px; border-radius:5px; font-family:monospace;">
                    <button class="btn btn-small" onclick="executeAdminCommand()">Execute</button>
                </div>
                <div style="margin-top:10px; font-size:11px; color:#888;">
                    <p>Commands: /give_money_[amount] | /give_damage_[amount] | /set_level_[level] | /god_mode | /reset | /unlock_all_levels</p>
                </div>
                <button class="close-btn" onclick="closeAdmin()">Close & Resume</button>
            </div>
             
        </div>

        <div class="game-over" id="gameOver">
            <h1 style="color:#ff0000;">üíÄ GAME OVER üíÄ</h1>
            <p style="margin-top:20px; font-size:18px;">Player: <span id="finalUsername">---</span></p>
            <p style="font-size:16px;">Final Level: <span id="finalLevel">1</span></p>
            <p style="font-size:16px;">Final Score: <span id="finalScore">0</span></p>
            <p style="font-size:16px;">Total Money: <span id="finalMoney">0</span></p>
            <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
                <button class="btn" onclick="restartLevel()">üîÑ RETRY LEVEL</button>
                <button class="btn secondary" onclick="logout()">üö™ EXIT</button>
            </div>
        </div>

        <div class="status-msg" id="statusMsg"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.7.1/firebase-firestore-compat.min.js"></script>
<script src="policySystem.js"></script>
<script src="authGuard.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBSmvM2LWEHd3A2bCgl599CNGQzLfdI2xc",
            authDomain: "the-rizzlers-web.firebaseapp.com",
            projectId: "the-rizzlers-web",
            storageBucket: "the-rizzlers-web.firebasestorage.app",
            messagingSenderId: "788402125100",
            appId: "1:788402125100:web:9570f9360aae9789d19489",
            measurementId: "G-LWG40Y7L90"
        };

        // Shared user database from index.html
        const inMemoryStorage = {
            users: new Set(['YASSINYASSINFREE', 'mody', 'yaamen','A D H A M Y','EYAD A','ABDO','MOHAMED','HASSONY','TEST','admin','faris', 'kimo', 'yassin_yasser', 'anas','farouk']),
            admins: new Set(['YASSINYASSINFREE','mody','admin','HASSONY','farouk','yassinsh']),
            banned: new Set(['MOHAMED']),
            userspassword: new Map([
                ['YASSINYASSINFREE', 'yassinyassinking'],
                ['mody', '1mody'],
                ['yaamen', 'deadpool'],
                ['admin', 'adminunknown'],
                ['A D H A M Y', 'adhamy'],
                ['EYAD A', 'eyada'],
                ['ABDO', 'abdo'],
                ['MOHAMED', 'mohamed'],
                ['HASSONY', 'hassony'],
                ['TEST', 'test'],
                ['faris', 'faris'],
                ['kimo','kimo_Ehab'],
                ['farouk','farfar'],
                ['yassin_yasser','yassin_yasser'],
                ['anas','anas1'],
                ['yassinsh','1234'],
                ['magdyyy','magdy1']
            ]),
        };

        const ADMIN_USERS = ['yassinyassinfree', 'mody', 'admin', 'HASSONY', 'MOHAMED', 'farouk'];

        let firebaseEnabled = false;
        let db = null;
        let currentUsername = '';
        let isUserLoggedIn = false;
        let autoSaveInterval = null;
        let isAdmin = false;
        let godMode = false;

        async function initializeFirebase() {
            try {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                await db.collection('_test').limit(1).get();
                firebaseEnabled = true;
                console.log('‚úÖ Firebase connected');
            } catch (err) {
                firebaseEnabled = false;
                console.warn('‚ö†Ô∏è Firebase not available', err);
            }
        }

        const SHIP_DESIGNS = [
            { name: 'Classic', speed: 6, fireRate: 120, color: '#00ff41' },
            { name: 'Rapid Fire', speed: 5, fireRate: 60, color: '#ff4444' },
            { name: 'Swift', speed: 8, fireRate: 150, color: '#44ccff' },
            { name: 'Assassin', speed: 7, fireRate: 200, color: '#9944ff' },
            { name: 'Destroyer', speed: 4, fireRate: 80, color: '#ff8800' },
            { name: 'Phantom', speed: 10, fireRate: 180, color: '#444444' },
            { name: 'Titan', speed: 3, fireRate: 100, color: '#ffaa00' },
            { name: 'Sniper', speed: 6, fireRate: 250, color: '#00ffaa' },
            { name: 'Blitz', speed: 9, fireRate: 70, color: '#ff00ff' },
            { name: 'Guardian', speed: 5, fireRate: 140, color: '#0088ff' },
            { name: 'Vortex', speed: 7, fireRate: 90, color: '#aa00ff' },
            { name: 'Nova', speed: 8, fireRate: 110, color: '#ffff00' },
            { name: 'Eclipse', speed: 6, fireRate: 130, color: '#666666' },
            { name: 'Storm', speed: 9, fireRate: 75, color: '#00aaff' },
            { name: 'Inferno', speed: 7, fireRate: 95, color: '#ff3300' },
            { name: 'Glacier', speed: 4, fireRate: 160, color: '#aaffff' },
            { name: 'Thunder', speed: 8, fireRate: 85, color: '#ffee00' },
            { name: 'Shadow', speed: 10, fireRate: 200, color: '#222222' },
            { name: 'Phoenix', speed: 6, fireRate: 120, color: '#ff6600' },
            { name: 'Leviathan', speed: 2, fireRate: 300, color: '#0044aa' }
        ];

        const SPECIAL_ABILITIES = [
            { name: 'Triple Shot', desc: 'Fire 3 bullets at once', effect: 'multishot' },
            { name: 'Speed Burst', desc: 'Move 50% faster', effect: 'speed' },
            { name: 'Piercing Bullets', desc: 'Bullets go through enemies', effect: 'pierce' },
            { name: 'Auto Fire', desc: 'Shoot automatically', effect: 'autofire' },
            { name: 'Shield Regen', desc: 'Regenerate HP over time', effect: 'regen' },
            { name: 'Critical Hits', desc: '25% chance for 3x damage', effect: 'crit' },
            { name: 'Homing Bullets', desc: 'Bullets track enemies', effect: 'homing' },
            { name: 'Bullet Time', desc: 'Slow down enemies', effect: 'slowmo' },
            { name: 'Double Damage', desc: 'Deal 2x damage', effect: 'doubledmg' },
            { name: 'Rapid Reload', desc: 'Fire 50% faster', effect: 'rapidfire' }
        ];

        const PUZZLE_TYPES = {
            dodge: { name: 'Dodge Master', desc: 'Avoid all enemies', color: '#44ccff' },
            destroy_all: { name: 'Exterminator', desc: 'Destroy all enemies', color: '#ff4444' },
            survive_time: { name: 'Survival', desc: 'Survive for time limit', color: '#ffaa00' },
            no_damage: { name: 'Perfect Run', desc: 'Take no damage', color: '#00ff41' },
            limited_bullets: { name: 'Sniper Challenge', desc: 'Limited bullets only', color: '#9944ff' },
            moving_obstacles: { name: 'Obstacle Course', desc: 'Navigate moving walls', color: '#aaffff' },
            fast_enemies: { name: 'Speed Challenge', desc: 'Very fast enemies', color: '#ff00ff' },
            shield_enemies: { name: 'Shield Breaker', desc: 'Enemies have shields', color: '#0088ff' },
            split_enemies: { name: 'Division', desc: 'Enemies split when hit', color: '#ff8800' },
            boss_rush: { name: 'Boss Battle', desc: 'Defeat the boss', color: '#ff0000' },
            bullet_hell: { name: 'Bullet Storm', desc: 'Extreme bullet density', color: '#ffff00' },
            precision: { name: 'Precision Strike', desc: 'Hit specific targets', color: '#00ffaa' },
            speedrun: { name: 'Time Attack', desc: 'Complete quickly', color: '#ffee00' },
            maze: { name: 'Labyrinth', desc: 'Navigate through maze', color: '#aa00ff' },
            pattern: { name: 'Pattern Recognition', desc: 'Follow the pattern', color: '#ffd700' }
        };

        const UPGRADES = {
            damage: { name: 'Bullet Damage', cost: 300, desc: '+1 bullet damage' },
            speed: { name: 'Ship Speed', cost: 250, desc: '+1 movement speed' },
            fireRate: { name: 'Fire Rate', cost: 400, desc: 'Shoot 15% faster' }
        };

        let score = 0, money = 0, hp = 100, level = 1, maxLevel = 1;
        let gameRunning = false;
        let currentShip = 'ship_0';
        let damageMultiplier = 1;
        let speedBonus = 0;
        let fireRateBonus = 0;
        let unlockedShips = {};
        let luckyBoxes = [];
        let currentPuzzle = null;
        let puzzleProgress = 0;
        let puzzleGoal = 10;
        let bulletsFired = 0;
        let puzzleStartTime = 0;
        let damageTaken = 0;
        let isBossFight = false;
        let bossEnemy = null;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const player = { x: canvas.width / 2 - 25, y: canvas.height - 60, width: 50, height: 50, color: '#00ff41' };
        const bullets = [], enemies = [];
        let enemySpawnTimer = 0;
        let bulletFireTimer = 0;
        const keys = {};
        let obstacles = [];
        let targetEnemies = [];
        let mazeWalls = [];

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') e.preventDefault();
        });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function generatePuzzleForLevel(lvl) {
            const seed = lvl * 12345;
            const rand = seededRandom(seed);
            const puzzleKeys = Object.keys(PUZZLE_TYPES);
            
            let puzzleType;
            if (lvl % 10 === 0) {
                puzzleType = 'boss_rush';
            } else if (lvl < 30) {
                const easyPuzzles = ['destroy_all', 'survive_time', 'dodge'];
                puzzleType = easyPuzzles[Math.floor(rand * easyPuzzles.length)];
            } else if (lvl < 60) {
                const mediumPuzzles = ['no_damage', 'limited_bullets', 'moving_obstacles', 'fast_enemies'];
                puzzleType = mediumPuzzles[Math.floor(rand * mediumPuzzles.length)];
            } else if (lvl < 100) {
                const hardPuzzles = ['shield_enemies', 'split_enemies', 'bullet_hell', 'precision'];
                puzzleType = hardPuzzles[Math.floor(rand * hardPuzzles.length)];
            } else {
                const insanePuzzles = ['speedrun', 'maze', 'pattern', 'bullet_hell'];
                puzzleType = insanePuzzles[Math.floor(rand * insanePuzzles.length)];
            }

            const puzzle = PUZZLE_TYPES[puzzleType];
            let goal = 15 + Math.floor(lvl / 3);
            let timeLimit = 40 + Math.floor(lvl / 2);
            
            if (puzzleType === 'limited_bullets') goal = Math.max(10, 15 - Math.floor(lvl / 20));
            if (puzzleType === 'survive_time') goal = timeLimit;
            if (puzzleType === 'speedrun') goal = Math.max(10, 45 - Math.floor(lvl / 3));
            if (puzzleType === 'boss_rush') goal = 1;
            if (puzzleType === 'precision') goal = 8 + Math.floor(lvl / 10);
            if (puzzleType === 'dodge') goal = 15 + Math.floor(lvl / 4);

            return { type: puzzleType, name: puzzle.name, desc: puzzle.desc, color: puzzle.color, goal, timeLimit };
        }

        function generateShipReward(lvl) {
            const seed = lvl * 54321;
            const rand = seededRandom(seed);
            const designIndex = Math.floor(rand * SHIP_DESIGNS.length);
            const design = SHIP_DESIGNS[designIndex];
            
            const abilityRand = seededRandom(seed + 100);
            let ability = null;
            if (abilityRand > 0.3) {
                const abilityIndex = Math.floor(abilityRand * SPECIAL_ABILITIES.length);
                ability = SPECIAL_ABILITIES[abilityIndex];
            }

            return {
                id: `ship_${lvl}`,
                name: design.name,
                speed: design.speed,
                fireRate: design.fireRate,
                color: design.color,
                ability: ability,
                level: lvl
            };
        }

        function calculateLevelReward(lvl) {
            const baseReward = 50;
            const multiplier = 1 + (lvl / 10);
            return Math.floor(baseReward * multiplier);
        }

        async function checkAuth() {
            await initializeFirebase();
            const savedUsername = sessionStorage.getItem('currentUsername');
            const savedLoginTime = sessionStorage.getItem('loginTime');
            
            if (savedUsername && savedLoginTime) {
                // Check session validity (24 hours)
                const loginTime = parseInt(savedLoginTime);
                const currentTime = Date.now();
                const hoursSinceLogin = (currentTime - loginTime) / (1000 * 60 * 60);
                
                if (hoursSinceLogin >= 24) {
                    // Session expired
                    sessionStorage.removeItem('currentUsername');
                    sessionStorage.removeItem('loginTime');
                    showLoginRequired();
                    return;
                }
                
                // Validate user against database
                if (await isUserValid(savedUsername)) {
                    currentUsername = savedUsername;
                    isUserLoggedIn = true;
                    isAdmin = ADMIN_USERS.includes(currentUsername);
                    showWelcomeScreen();
                    setTimeout(startGame, 600);
                } else {
                    // User not valid (banned or doesn't exist)
                    sessionStorage.removeItem('currentUsername');
                    sessionStorage.removeItem('loginTime');
                    showLoginRequired();
                }
            } else {
                showLoginRequired();
            }
        }

        async function isUserValid(username) {
            // Check if user is banned
            const lowerUsername = username.toLowerCase();
            for (let banned of inMemoryStorage.banned) {
                if (banned.toLowerCase() === lowerUsername) {
                    alert('‚õî Access Denied: You are banned from this system.');
                    return false;
                }
            }
            
            // Check if user exists in database
            let userExists = false;
            for (let user of inMemoryStorage.users) {
                if (user.toLowerCase() === lowerUsername) {
                    userExists = true;
                    break;
                }
            }
            if (!userExists) {
                for (let admin of inMemoryStorage.admins) {
                    if (admin.toLowerCase() === lowerUsername) {
                        userExists = true;
                        break;
                    }
                }
            }
            
            if (!userExists) {
                alert('‚õî Access Denied: Please login through index.html first.');
                return false;
            }
            
            return true;
        }

        function showWelcomeScreen() {
            document.getElementById('loginCheck').innerHTML = `<h1>[ WELCOME ]</h1><p style="font-size:24px; color:#00ff41;">${currentUsername.toUpperCase()}</p><p>Loading game...</p>`;
        }

        function showLoginRequired() {
            document.getElementById('loginCheck').classList.add('hidden');
            document.getElementById('loginRequired').classList.remove('hidden');
        }

        async function doLogin() {
            const input = document.getElementById('usernameInput').value.trim();
            if (!input) { showStatus('‚ùå Enter username'); return; }
            
            // Validate user before allowing login
            if (await isUserValid(input)) {
                sessionStorage.setItem('currentUsername', input);
                sessionStorage.setItem('loginTime', Date.now().toString());
                currentUsername = input;
                isUserLoggedIn = true;
                isAdmin = ADMIN_USERS.includes(currentUsername);
                showWelcomeScreen();
                setTimeout(startGame, 600);
            }
        }

        async function startGame() {
            document.getElementById('loginCheck').classList.add('hidden');
            document.getElementById('loginRequired').classList.add('hidden');
            document.getElementById('gameContainer').style.display = 'block';
            document.getElementById('username').textContent = currentUsername;
            document.getElementById('finalUsername').textContent = currentUsername;

            if (isAdmin) {
                document.getElementById('adminBtn').style.display = 'block';
            }

            unlockedShips['ship_0'] = {
                id: 'ship_0',
                name: 'Classic',
                speed: 6,
                fireRate: 120,
                color: '#00ff41',
                ability: null,
                level: 0
            };

            if (firebaseEnabled && db) {
                try {
                    const playerDoc = await db.collection('players').doc(currentUsername).get();
                    if (playerDoc.exists) {
                        const data = playerDoc.data();
                        score = data.score || 0;
                        money = data.money || 0;
                        level = data.level || 1;
                        maxLevel = data.maxLevel || 1;
                        hp = 100;
                        damageMultiplier = Math.min(data.damageMultiplier || 1, 75);
                        speedBonus = Math.min(data.speedBonus || 0, 75);
                        fireRateBonus = Math.min(data.fireRateBonus || 0, 75);
                        currentShip = data.currentShip || 'ship_0';
                        unlockedShips = data.unlockedShips || { ship_0: unlockedShips.ship_0 };
                        luckyBoxes = data.luckyBoxes || [];
                        showStatus('‚úÖ Welcome back!');
                    } else {
                        showStatus('üéÆ New player!');
                        await createPlayerRecord();
                    }
                } catch (err) {
                    console.error('Load error:', err);
                }
            }

            updateHUD();
            startLevel(level);
        }

        async function createPlayerRecord() {
            if (!firebaseEnabled || !db) return;
            try {
                await db.collection('players').doc(currentUsername).set({
                    username: currentUsername,
                    score: 0,
                    money: 0,
                    level: 1,
                    maxLevel: 1,
                    damageMultiplier: 1,
                    speedBonus: 0,
                    fireRateBonus: 0,
                    currentShip: 'ship_0',
                    unlockedShips: { ship_0: unlockedShips.ship_0 },
                    luckyBoxes: [],
                    createdAt: new Date(),
                    lastPlayed: new Date()
                });
            } catch (err) {
                console.error('Create error:', err);
            }
        }

        function startAutoSave() {
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            autoSaveInterval = setInterval(saveProgress, 3000);
        }

        function stopAutoSave() {
            if (autoSaveInterval) clearInterval(autoSaveInterval);
        }

        async function saveProgress() {
            if (!isUserLoggedIn || !firebaseEnabled || !db) return;
            try {
                await db.collection('players').doc(currentUsername).set({
                    username: currentUsername,
                    score,
                    money,
                    level,
                    maxLevel,
                    damageMultiplier,
                    speedBonus,
                    fireRateBonus,
                    currentShip,
                    unlockedShips,
                    luckyBoxes,
                    lastPlayed: new Date()
                }, { merge: true });
            } catch (err) {
                console.error('Save error:', err);
            }
        }

        function startLevel(lvl) {
            level = lvl;
            hp = 100;
            bullets.length = 0;
            enemies.length = 0;
            obstacles.length = 0;
            targetEnemies.length = 0;
            mazeWalls.length = 0;
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height - 60;
            isBossFight = false;
            bossEnemy = null;
            
            currentPuzzle = generatePuzzleForLevel(lvl);
            puzzleProgress = 0;
            bulletsFired = 0;
            puzzleStartTime = Date.now();
            damageTaken = 0;

            if (currentPuzzle.type === 'boss_rush') {
                isBossFight = true;
                showBossWarning();
            }

            if (currentPuzzle.type === 'moving_obstacles') {
                for (let i = 0; i < 5 + Math.floor(lvl / 5); i++) {
                    obstacles.push({
                        x: Math.random() * (canvas.width - 60),
                        y: Math.random() * (canvas.height - 100) + 50,
                        width: 60,
                        height: 20,
                        speedX: (Math.random() - 0.5) * (4 + lvl / 20),
                        speedY: (Math.random() - 0.5) * (4 + lvl / 20)
                    });
                }
            }

            if (currentPuzzle.type === 'maze') {
                generateMaze();
            }

            if (currentPuzzle.type === 'precision') {
                for (let i = 0; i < currentPuzzle.goal; i++) {
                    targetEnemies.push({
                        x: Math.random() * (canvas.width - 40),
                        y: Math.random() * (canvas.height / 2),
                        width: 40,
                        height: 40,
                        isTarget: true,
                        color: '#ffff00'
                    });
                }
            }

            updateHUD();
            gameRunning = true;
            startAutoSave();
            gameLoop();
        }

        function showBossWarning() {
            const warning = document.getElementById('bossWarning');
            warning.style.display = 'block';
            setTimeout(() => {
                warning.style.display = 'none';
                spawnBoss();
            }, 2000);
        }

        function spawnBoss() {
            const bossHealth = 50 + (level * 15);
            bossEnemy = {
                x: canvas.width / 2 - 75,
                y: 50,
                width: 150,
                height: 150,
                color: '#ff00ff',
                health: bossHealth,
                maxHealth: bossHealth,
                isBoss: true,
                moveDirection: 1,
                shootTimer: 0,
                phase: 1
            };
            enemies.push(bossEnemy);
        }

        function generateMaze() {
            const rows = 6 + Math.floor(level / 15);
            const cols = 8 + Math.floor(level / 15);
            const cellWidth = canvas.width / cols;
            const cellHeight = (canvas.height - 100) / rows;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const density = 0.5 + (level / 200);
                    if (Math.random() > density && !(i === rows - 1 && j === Math.floor(cols / 2))) {
                        mazeWalls.push({
                            x: j * cellWidth,
                            y: i * cellHeight + 50,
                            width: cellWidth,
                            height: cellHeight
                        });
                    }
                }
            }
        }

        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('money').textContent = money;
            document.getElementById('hp').textContent = hp;
            document.getElementById('level').textContent = level;
            document.getElementById('maxLevel').textContent = maxLevel;
            document.getElementById('damage').textContent = damageMultiplier;
            
            const ship = unlockedShips[currentShip];
            if (ship) {
                document.getElementById('shipname').textContent = ship.name;
                player.color = ship.color;
            }

            if (currentPuzzle) {
                document.getElementById('puzzleType').textContent = currentPuzzle.name;
                let goalText = '';
                if (currentPuzzle.type === 'destroy_all' || currentPuzzle.type === 'precision') {
                    goalText = `${puzzleProgress}/${currentPuzzle.goal}`;
                } else if (currentPuzzle.type === 'survive_time' || currentPuzzle.type === 'speedrun') {
                    const elapsed = Math.floor((Date.now() - puzzleStartTime) / 1000);
                    goalText = `${elapsed}s / ${currentPuzzle.goal}s`;
                } else if (currentPuzzle.type === 'limited_bullets') {
                    goalText = `Bullets: ${bulletsFired}/${currentPuzzle.goal}`;
                } else if (currentPuzzle.type === 'no_damage') {
                    goalText = `Damage: ${damageTaken}`;
                } else if (currentPuzzle.type === 'boss_rush') {
                    goalText = bossEnemy ? `Boss HP: ${bossEnemy.health}/${bossEnemy.maxHealth}` : 'Defeat Boss';
                } else {
                    goalText = `${puzzleProgress}/${currentPuzzle.goal}`;
                }
                document.getElementById('puzzleGoal').textContent = goalText;
            }
        }

        function shootBullet() {
            if (!gameRunning) return;
            
            const ship = unlockedShips[currentShip];
            if (currentPuzzle.type === 'limited_bullets') {
                bulletsFired++;
                if (bulletsFired > currentPuzzle.goal) {
                    endGame();
                    return;
                }
            }

            const bulletDmg = damageMultiplier;
            let count = 1;
            
            if (ship && ship.ability && ship.ability.effect === 'multishot') {
                count = 3;
            }

            for (let i = 0; i < count; i++) {
                const offset = count === 1 ? 0 : (i - 1) * 15;
                bullets.push({ 
                    x: player.x + 23 + offset, 
                    y: player.y, 
                    width: 4, 
                    height: 10, 
                    color: '#ffff00', 
                    damage: bulletDmg,
                    pierce: ship && ship.ability && ship.ability.effect === 'pierce'
                });
            }
        }

        function update() {
            if (!gameRunning) return;
            
            const ship = unlockedShips[currentShip];
            let speed = (ship ? ship.speed : 6) + speedBonus;
            
            if (ship && ship.ability && ship.ability.effect === 'speed') {
                speed *= 1.5;
            }

            if (keys['ArrowLeft'] && player.x > 0) {
                let canMove = true;
                for (let wall of mazeWalls) {
                    if (collision({ x: player.x - speed, y: player.y, width: player.width, height: player.height }, wall)) {
                        canMove = false;
                        break;
                    }
                }
                if (canMove) player.x -= speed;
            }
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
                let canMove = true;
                for (let wall of mazeWalls) {
                    if (collision({ x: player.x + speed, y: player.y, width: player.width, height: player.height }, wall)) {
                        canMove = false;
                        break;
                    }
                }
                if (canMove) player.x += speed;
            }
            if (keys['ArrowUp'] && player.y > canvas.height / 2) {
                let canMove = true;
                for (let wall of mazeWalls) {
                    if (collision({ x: player.x, y: player.y - speed, width: player.width, height: player.height }, wall)) {
                        canMove = false;
                        break;
                    }
                }
                if (canMove) player.y -= speed;
            }
            if (keys['ArrowDown'] && player.y < canvas.height - player.height) {
                let canMove = true;
                for (let wall of mazeWalls) {
                    if (collision({ x: player.x, y: player.y + speed, width: player.width, height: player.height }, wall)) {
                        canMove = false;
                        break;
                    }
                }
                if (canMove) player.y += speed;
            }

            bulletFireTimer++;
            const fireRate = Math.max(20, (ship ? ship.fireRate : 120) - fireRateBonus);
            
            const autoFire = ship && ship.ability && ship.ability.effect === 'autofire';
            if ((keys['Space'] || autoFire) && bulletFireTimer > fireRate) { 
                shootBullet(); 
                bulletFireTimer = 0; 
            }

            for (let i = bullets.length-1; i>=0; i--) {
                bullets[i].y -= 7;
                if (bullets[i].y < 0) bullets.splice(i,1);
            }

            for (let i = obstacles.length-1; i>=0; i--) {
                obstacles[i].x += obstacles[i].speedX;
                obstacles[i].y += obstacles[i].speedY;

                if (obstacles[i].x <= 0 || obstacles[i].x >= canvas.width - obstacles[i].width) {
                    obstacles[i].speedX *= -1;
                }
                if (obstacles[i].y <= 0 || obstacles[i].y >= canvas.height - obstacles[i].height) {
                    obstacles[i].speedY *= -1;
                }

                if (collision(player, obstacles[i])) {
                    if (!godMode) {
                        hp -= 5;
                        damageTaken += 5;
                        updateHUD();
                        if (hp <= 0) endGame();
                    }
                }
            }

            if (!isBossFight && currentPuzzle.type !== 'precision') {
                enemySpawnTimer++;
                let spawnRate = Math.max(15, 50 - level);
                
                if (currentPuzzle.type === 'fast_enemies') spawnRate = Math.max(8, 30 - level);
                if (currentPuzzle.type === 'bullet_hell') spawnRate = Math.max(3, 15 - level);
                
                if (enemySpawnTimer > spawnRate) {
                    const enemySpeed = currentPuzzle.type === 'fast_enemies' ? 4 : 2;
                    const hasShield = currentPuzzle.type === 'shield_enemies';
                    
                    enemies.push({ 
                        x: Math.random() * (canvas.width - 40), 
                        y: -40, 
                        width: 40, 
                        height: 40, 
                        color: hasShield ? '#00aaff' : '#ff0000',
                        health: hasShield ? Math.min(3 + Math.floor(level / 20), 8) : 1,
                        maxHealth: hasShield ? Math.min(3 + Math.floor(level / 20), 8) : 1,
                        isBoss: false,
                        speed: enemySpeed,
                        shootTimer: 0,
                        canShoot: currentPuzzle.type === 'bullet_hell'
                    });
                    enemySpawnTimer = 0;
                }
            }

            for (let i = enemies.length -1; i >= 0; i--) {
                if (enemies[i].isBoss) {
                    enemies[i].x += enemies[i].moveDirection * 3;
                    if (enemies[i].x <= 0 || enemies[i].x >= canvas.width - enemies[i].width) {
                        enemies[i].moveDirection *= -1;
                    }
                    
                    enemies[i].shootTimer++;
                    const bossFireRate = Math.max(20, 60 - level);
                    const bulletCount = Math.min(3 + Math.floor(level / 20), 7);
                    if (enemies[i].shootTimer > bossFireRate) {
                        for (let j = 0; j < bulletCount; j++) {
                            bullets.push({
                                x: enemies[i].x + (j * (enemies[i].width / (bulletCount - 1))),
                                y: enemies[i].y + enemies[i].height,
                                width: 6,
                                height: 12,
                                color: '#ff00ff',
                                damage: 10,
                                isEnemyBullet: true
                            });
                        }
                        enemies[i].shootTimer = 0;
                    }
                } else {
                    if (enemies[i].isTarget) {
                        continue;
                    }
                    
                    enemies[i].y += enemies[i].speed || 2;
                    
                    if (enemies[i].canShoot) {
                        enemies[i].shootTimer++;
                        const shootRate = Math.max(30, 90 - level);
                        if (enemies[i].shootTimer > shootRate) {
                            bullets.push({
                                x: enemies[i].x + enemies[i].width / 2,
                                y: enemies[i].y + enemies[i].height,
                                width: 4,
                                height: 8,
                                color: '#ff4444',
                                damage: 5,
                                isEnemyBullet: true
                            });
                            enemies[i].shootTimer = 0;
                        }
                    }
                }
                
                if (enemies[i].y > canvas.height) {
                    if (currentPuzzle.type === 'dodge') {
                        puzzleProgress++;
                    }
                    enemies.splice(i,1);
                }
            }

            document.getElementById('enemies-count').textContent = enemies.length;

            for (let b = bullets.length-1; b>=0; b--) {
                if (bullets[b].isEnemyBullet) {
                    bullets[b].y += 5;
                    if (bullets[b].y > canvas.height) {
                        bullets.splice(b, 1);
                        continue;
                    }
                    if (collision(bullets[b], player)) {
                        bullets.splice(b, 1);
                        if (!godMode) {
                            hp -= bullets[b]?.damage || 10;
                            damageTaken += bullets[b]?.damage || 10;
                            updateHUD();
                            if (hp <= 0) endGame();
                        }
                    }
                    continue;
                }

                let bulletHit = false;
                for (let e = enemies.length-1; e>=0; e--) {
                    if (collision(bullets[b], enemies[e])) {
                        const crit = ship && ship.ability && ship.ability.effect === 'crit' && Math.random() < 0.25;
                        const damage = crit ? bullets[b].damage * 3 : bullets[b].damage;
                        
                        enemies[e].health -= damage;
                        
                        if (!bullets[b].pierce) {
                            bullets.splice(b,1);
                            bulletHit = true;
                        }
                        
                        if (enemies[e].health <= 0) {
                            if (enemies[e].isBoss) {
                                completePuzzle();
                            } else {
                                if (currentPuzzle.type === 'split_enemies' && !enemies[e].isSplit) {
                                    for (let s = 0; s < 2; s++) {
                                        enemies.push({
                                            x: enemies[e].x + (s * 20),
                                            y: enemies[e].y,
                                            width: 20,
                                            height: 20,
                                            color: '#ff8800',
                                            health: 1,
                                            maxHealth: 1,
                                            isBoss: false,
                                            speed: 3,
                                            isSplit: true
                                        });
                                    }
                                }

                                if (currentPuzzle.type === 'destroy_all' || currentPuzzle.type === 'precision' && enemies[e].isTarget) {
                                    puzzleProgress++;
                                    if (enemies[e].isTarget) {
                                        targetEnemies.splice(targetEnemies.indexOf(enemies[e]), 1);
                                    }
                                }

                                const luckyChance = 0.05 + (level / 1000);
                                if (Math.random() < luckyChance && !enemies[e].isTarget) {
                                    spawnLuckyBox(enemies[e].x, enemies[e].y);
                                }

                                const reward = Math.floor(5 + (level * 0.5));
                                money += reward;
                            }
                            enemies.splice(e,1);
                        }
                        updateHUD();
                        if (bulletHit) break;
                    }
                }
            }

            for (let i = enemies.length-1; i>=0; i--) {
                if (!enemies[i].isBoss && !enemies[i].isTarget && collision(player, enemies[i])) {
                    enemies.splice(i,1);
                    if (!godMode) {
                        hp -= 20;
                        damageTaken += 20;
                        updateHUD();
                        if (hp <= 0) endGame();
                    }
                }
            }

            checkPuzzleCompletion();

            if (ship && ship.ability && ship.ability.effect === 'regen') {
                if (Date.now() % 60 === 0 && hp < 100) {
                    hp = Math.min(100, hp + 1);
                    updateHUD();
                }
            }
        }

        function spawnLuckyBox(x, y) {
            const box = {
                x: x,
                y: y,
                width: 30,
                height: 30,
                collected: false
            };
            
            const checkCollision = setInterval(() => {
                if (collision(player, box) && !box.collected) {
                    box.collected = true;
                    clearInterval(checkCollision);
                    openLuckyBoxReward();
                }
            }, 100);

            setTimeout(() => clearInterval(checkCollision), 10000);
        }

        function openLuckyBoxReward() {
            gameRunning = false;
            const randomShip = generateShipReward(Math.floor(Math.random() * 150) + 1);
            
            const html = `
                <div class="lucky-box">üéÅ</div>
                <h3 style="color:#ffd700;">YOU GOT A NEW SHIP!</h3>
                <div class="shop-item" style="margin:20px 0;">
                    <div class="shop-item-info">
                        <div class="shop-item-name" style="font-size:20px;">${randomShip.name}</div>
                        <div class="shop-item-desc">Speed: ${randomShip.speed} | Fire Rate: ${randomShip.fireRate}</div>
                        ${randomShip.ability ? `<div class="shop-item-desc" style="color:#ffff00;">‚ö° Ability: ${randomShip.ability.name} - ${randomShip.ability.desc}</div>` : ''}
                    </div>
                </div>
            `;
            
            document.getElementById('luckyBoxContent').innerHTML = html;
            document.getElementById('luckyBoxModal').classList.add('active');
            
            unlockedShips[randomShip.id] = randomShip;
            luckyBoxes.push(randomShip);
            saveProgress();
            showStatus('üéÅ Lucky Box opened!');
        }

        function closeLuckyBox() {
            document.getElementById('luckyBoxModal').classList.remove('active');
            gameRunning = true;
        }

        function checkPuzzleCompletion() {
            if (!currentPuzzle) return;

            let completed = false;

            if (currentPuzzle.type === 'destroy_all' || currentPuzzle.type === 'precision') {
                if (puzzleProgress >= currentPuzzle.goal) completed = true;
            } else if (currentPuzzle.type === 'survive_time') {
                const elapsed = Math.floor((Date.now() - puzzleStartTime) / 1000);
                if (elapsed >= currentPuzzle.goal) completed = true;
            } else if (currentPuzzle.type === 'no_damage') {
                if (damageTaken > 0 && enemies.length === 0) {
                    endGame();
                    return;
                }
                const elapsed = Math.floor((Date.now() - puzzleStartTime) / 1000);
                if (elapsed >= 30 && damageTaken === 0) completed = true;
            } else if (currentPuzzle.type === 'dodge') {
                if (puzzleProgress >= currentPuzzle.goal) completed = true;
            } else if (currentPuzzle.type === 'speedrun') {
                const elapsed = Math.floor((Date.now() - puzzleStartTime) / 1000);
                if (enemies.length === 0 && elapsed <= currentPuzzle.goal) completed = true;
                if (elapsed > currentPuzzle.goal) {
                    endGame();
                    return;
                }
            }

            if (completed) {
                completePuzzle();
            }
        }

        function completePuzzle() {
            gameRunning = false;
            stopAutoSave();

            const reward = calculateLevelReward(level);
            const scoreGain = reward * 10;
            money += reward;
            score += scoreGain;

            const shipReward = generateShipReward(level);
            unlockedShips[shipReward.id] = shipReward;

            if (level >= maxLevel) {
                maxLevel = level + 1;
            }

            saveProgress();

            showStatus(`‚úÖ Level ${level} Complete! +${reward} money, +${scoreGain} score, New Ship: ${shipReward.name}!`);

            setTimeout(() => {
                if (level < 150) {
                    startLevel(level + 1);
                } else {
                    showStatus('üéâ YOU COMPLETED ALL 150 LEVELS! üéâ');
                }
            }, 3000);
        }

        function collision(a,b) {
            return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
        }

        function draw() {
            ctx.fillStyle = '#000'; 
            ctx.fillRect(0,0,canvas.width,canvas.height);

            for (let wall of mazeWalls) {
                ctx.fillStyle = '#444';
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            }

            for (let obs of obstacles) {
                ctx.fillStyle = '#888';
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
            }
            
            ctx.fillStyle = player.color; 
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.fillStyle = '#fff'; 
            ctx.fillRect(player.x + 20, player.y - 10, 10, 20);
            ctx.fillStyle = '#ff0000'; 
            ctx.fillRect(player.x + 10, player.y + 40, 30, 10);

            bullets.forEach(b => { 
                ctx.fillStyle = b.color; 
                ctx.fillRect(b.x, b.y, b.width, b.height); 
            });
            
            enemies.forEach(e => {
                ctx.fillStyle = e.color; 
                ctx.fillRect(e.x, e.y, e.width, e.height);
                
                if (e.isBoss) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('BOSS', e.x + e.width/2, e.y + e.height/2);
                    
                    const healthBarWidth = e.width;
                    const healthBarHeight = 10;
                    const healthPercent = e.health / e.maxHealth;
                    
                    ctx.fillStyle = '#333';
                    ctx.fillRect(e.x, e.y - 20, healthBarWidth, healthBarHeight);
                    ctx.fillStyle = '#00ff41';
                    ctx.fillRect(e.x, e.y - 20, healthBarWidth * healthPercent, healthBarHeight);
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Arial';
                    ctx.fillText(`${e.health}/${e.maxHealth}`, e.x + e.width/2, e.y - 25);
                }

                if (e.isTarget) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚≠ê', e.x + e.width/2, e.y + e.height/2 + 5);
                }

                if (e.maxHealth > 1 && !e.isBoss) {
                    const healthBarWidth = e.width;
                    const healthBarHeight = 5;
                    const healthPercent = e.health / e.maxHealth;
                    
                    ctx.fillStyle = '#333';
                    ctx.fillRect(e.x, e.y - 10, healthBarWidth, healthBarHeight);
                    ctx.fillStyle = '#00aaff';
                    ctx.fillRect(e.x, e.y - 10, healthBarWidth * healthPercent, healthBarHeight);
                }
            });
        }

        function gameLoop() { 
            update(); 
            draw(); 
            requestAnimationFrame(gameLoop); 
        }

        function endGame() {
            gameRunning = false;
            stopAutoSave();
            saveProgress();
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalMoney').textContent = money;
            document.getElementById('gameOver').classList.add('active');
        }

        function restartLevel() {
            document.getElementById('gameOver').classList.remove('active');
            startLevel(level);
        }

        function logout() {
            gameRunning = false;
            stopAutoSave();
            saveProgress();
            sessionStorage.removeItem('currentUsername');
            sessionStorage.removeItem('loginTime');
            window.location.href = 'index.html';
        }

        function showStatus(msg) {
            const statusEl = document.getElementById('statusMsg');
            statusEl.textContent = msg;
            statusEl.classList.add('show');
            setTimeout(() => statusEl.classList.remove('show'), 3000);
        }

        function openLevelSelect() {
            gameRunning = false;
            let html = '';
            
            for (let i = 1; i <= 150; i++) {
                const puzzle = generatePuzzleForLevel(i);
                const unlocked = i <= maxLevel;
                const isCurrent = i === level;
                const isBoss = i % 10 === 0;
                
                let btnClass = 'level-btn';
                if (!unlocked) btnClass += ' locked';
                if (isCurrent) btnClass += ' current';
                if (isBoss) btnClass += ' boss';
                
                const onclick = unlocked ? `onclick="selectLevel(${i})"` : '';
                
                html += `
                    <div class="${btnClass}" ${onclick}>
                        <div style="font-size:18px; font-weight:bold;">${i}</div>
                        <div style="font-size:10px; margin-top:5px;">${puzzle.name}</div>
                        ${isBoss ? '<div style="font-size:10px; color:#ff00ff;">üëë BOSS</div>' : ''}
                        ${!unlocked ? '<div style="font-size:10px;">üîí</div>' : ''}
                    </div>
                `;
            }
            
            document.getElementById('levelSelectContent').innerHTML = html;
            document.getElementById('levelSelectModal').classList.add('active');
        }

        function closeLevelSelect() {
            document.getElementById('levelSelectModal').classList.remove('active');
            gameRunning = true;
        }

        function selectLevel(lvl) {
            closeLevelSelect();
            startLevel(lvl);
        }

        function openShop() {
            gameRunning = false;
            const shopHtml = [];
            
            shopHtml.push('<h3 style="margin-top:0;">üöÄ UNLOCKED SHIPS</h3>');
            for (let key in unlockedShips) {
                const ship = unlockedShips[key];
                const isCurrent = currentShip === key;
                shopHtml.push(`
                    <div class="shop-item">
                        <div class="shop-item-info">
                            <div class="shop-item-name">${ship.name} ${isCurrent ? '‚úÖ EQUIPPED' : ''}</div>
                            <div class="shop-item-desc">Speed: ${ship.speed} | Fire Rate: ${ship.fireRate}</div>
                            ${ship.ability ? `<div class="shop-item-desc" style="color:#ffff00;">‚ö° ${ship.ability.name}: ${ship.ability.desc}</div>` : ''}
                        </div>
                        <div>
                            ${isCurrent ? '<button class="btn btn-small" disabled>USING</button>' : 
                                `<button class="btn btn-small" onclick="equipShip('${key}')">EQUIP</button>`}
                        </div>
                    </div>
                `);
            }

            shopHtml.push('<h3>‚¨ÜÔ∏è UPGRADES</h3>');
            for (let key in UPGRADES) {
                const upgrade = UPGRADES[key];
                shopHtml.push(`
                    <div class="shop-item">
                        <div class="shop-item-info">
                            <div class="shop-item-name">${upgrade.name}</div>
                            <div class="shop-item-desc">${upgrade.desc}</div>
                        </div>
                        <button class="btn btn-small" onclick="buyUpgrade('${key}')">${upgrade.cost} üí∞</button>
                    </div>
                `);
            }

            document.getElementById('shopItems').innerHTML = shopHtml.join('');
            document.getElementById('shopModal').classList.add('active');
        }

        function closeShop() {
            document.getElementById('shopModal').classList.remove('active');
            gameRunning = true;
        }

        function equipShip(shipKey) {
            currentShip = shipKey;
            updateHUD();
            saveProgress();
            showStatus(`‚úÖ Equipped ${unlockedShips[shipKey].name}!`);
            openShop();
        }

        function buyUpgrade(upgradeKey) {
            const upgrade = UPGRADES[upgradeKey];
            if (money >= upgrade.cost) {
                money -= upgrade.cost;
                if (upgradeKey === 'damage') damageMultiplier++;
                if (upgradeKey === 'speed') speedBonus++;
                if (upgradeKey === 'fireRate') fireRateBonus += 15;
                updateHUD();
                saveProgress();
                showStatus(`‚úÖ Upgraded ${upgrade.name}!`);
                openShop();
            } else {
                showStatus('‚ùå Not enough money!');
            }
        }

     async function openLeaderboard() {
            gameRunning = false;
            document.getElementById('leaderboardContent').innerHTML = '<p style="text-align:center;">Loading...</p>';
            document.getElementById('leaderboardModal').classList.add('active');

            if (!firebaseEnabled || !db) {
                document.getElementById('leaderboardContent').innerHTML = '<p style="text-align:center; color:#ff0000;">Firebase not available</p>';
                return;
            }

            try {
                // Fetch all players with error handling
                const snapshot = await db.collection('players').get().catch(err => {
                    console.error('Firebase fetch error:', err);
                    throw new Error('Failed to fetch players');
                });

                const players = [];
                
                // Safely extract player data
                snapshot.forEach(doc => {
                    try {
                        const data = doc.data();
                        if (data && data.username) {
                            players.push({
                                username: data.username || 'Unknown',
                                maxLevel: parseInt(data.maxLevel) || 1,
                                score: parseInt(data.score) || 0,
                                money: parseInt(data.money) || 0,
                                damageMultiplier: parseInt(data.damageMultiplier) || 1
                            });
                        }
                    } catch (e) {
                        console.warn('Skipping invalid player doc:', e);
                    }
                });

                if (players.length === 0) {
                    document.getElementById('leaderboardContent').innerHTML = '<p style="text-align:center;">No players yet. Be the first to play!</p>';
                    return;
                }

                // Sort by maxLevel (descending), then by score (descending)
                players.sort((a, b) => {
                    const levelDiff = b.maxLevel - a.maxLevel;
                    if (levelDiff !== 0) return levelDiff;
                    return b.score - a.score;
                });

                // Limit to top 50
                const topPlayers = players.slice(0, 50);

                let html = '<table><thead><tr><th>Rank</th><th>Player</th><th>Max Level</th><th>Score</th><th>Money</th><th>Damage</th></tr></thead><tbody>';
                topPlayers.forEach((p, i) => {
                    const rankClass = i === 0 ? 'rank-1' : i === 1 ? 'rank-2' : i === 2 ? 'rank-3' : '';
                    const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
                    html += `<tr class="${rankClass}">
                        <td>${medal} #${i+1}</td>
                        <td>${p.username}</td>
                        <td>${p.maxLevel}</td>
                        <td>${p.score.toLocaleString()}</td>
                        <td>${p.money.toLocaleString()}</td>
                        <td>${p.damageMultiplier}x</td>
                    </tr>`;
                });
                html += '</tbody></table>';
                
                document.getElementById('leaderboardContent').innerHTML = html;
                console.log('‚úÖ Leaderboard loaded successfully with', topPlayers.length, 'players');
                
            } catch (err) {
                console.error('Leaderboard error details:', err);
                const errorMsg = err.message || 'Unknown error occurred';
                document.getElementById('leaderboardContent').innerHTML = `
                    <div style="text-align:center; padding:20px;">
                        <p style="color:#ff0000; margin-bottom:10px;">‚ö†Ô∏è Error Loading Leaderboard</p>
                        <p style="color:#888; font-size:12px;">${errorMsg}</p>
                        <p style="color:#888; font-size:12px; margin-top:10px;">Please try again later or check your connection.</p>
                    </div>
                `;
            }
        }

        function closeLeaderboard() {
            document.getElementById('leaderboardModal').classList.remove('active');
            gameRunning = true;
        }

        function openAdmin() {
            if (!isAdmin) return;
            gameRunning = false;
            document.getElementById('adminModal').classList.add('active');
            addAdminLog('Admin panel opened. Type a command and press Execute.');
        }

        function closeAdmin() {
            document.getElementById('adminModal').classList.remove('active');
            gameRunning = true;
        }

        function addAdminLog(msg) {
            const output = document.getElementById('adminOutput');
            const time = new Date().toLocaleTimeString();
            output.innerHTML += `<div>[${time}] ${msg}</div>`;
            output.scrollTop = output.scrollHeight;
        }

        function executeAdminCommand() {
            const input = document.getElementById('adminInput');
            const cmd = input.value.trim();
            input.value = '';

            if (!cmd) return;
            addAdminLog(`> ${cmd}`);

            if (cmd.startsWith('/give_money_')) {
                const amount = parseInt(cmd.split('_')[2]);
                if (!isNaN(amount)) {
                    money += amount;
                    updateHUD();
                    saveProgress();
                    addAdminLog(`‚úÖ Added ${amount} money`);
                } else {
                    addAdminLog('‚ùå Invalid amount');
                }
            } else if (cmd.startsWith('/give_damage_')) {
                const amount = parseInt(cmd.split('_')[2]);
                if (!isNaN(amount)) {
                    damageMultiplier += amount;
                    updateHUD();
                    saveProgress();
                    addAdminLog(`‚úÖ Added ${amount} damage`);
                } else {
                    addAdminLog('‚ùå Invalid amount');
                }
            } else if (cmd.startsWith('/set_level_')) {
                const lvl = parseInt(cmd.split('_')[2]);
                if (!isNaN(lvl) && lvl > 0 && lvl <= 150) {
                    level = lvl;
                    if (lvl > maxLevel) maxLevel = lvl;
                    updateHUD();
                    saveProgress();
                    addAdminLog(`‚úÖ Set level to ${lvl}`);
                    closeAdmin();
                    startLevel(lvl);
                } else {
                    addAdminLog('‚ùå Invalid level (1-150)');
                }
            } else if (cmd === '/god_mode') {
                godMode = !godMode;
                addAdminLog(`‚úÖ God mode ${godMode ? 'ENABLED' : 'DISABLED'}`);
                if (godMode) {
                    hp = 999;
                    updateHUD();
                }
            } else if (cmd === '/reset') {
                score = 0;
                money = 0;
                updateHUD();
                saveProgress();
                addAdminLog('‚úÖ Score and money reset (levels and ships preserved)');
            } else if (cmd === '/unlock_all_levels') {
                maxLevel = 150;
                updateHUD();
                saveProgress();
                addAdminLog('‚úÖ All 150 levels unlocked');
            } else {
                addAdminLog('‚ùå Unknown command');
            }
        }

        checkAuth();
    </script>
    <script>
// ADD THIS TO YOUR game.html SCRIPT SECTION
// Place this code after the existing function definitions, before checkAuth();

// ==================== ADVANCED FIREBASE TRADING SYSTEM ====================

let pendingTrades = [];
let sentGifts = [];
let receivedGifts = [];
let tradeHistory = [];

async function openTrading() {
    gameRunning = false;
    const modal = document.getElementById('tradingModal') || createTradingModal();
    modal.classList.add('active');
    await loadTradingUI();
}

function createTradingModal() {
    if (document.getElementById('tradingModal')) {
        return document.getElementById('tradingModal');
    }
    
    const modal = document.createElement('div');
    modal.id = 'tradingModal';
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 1200px; max-height: 90vh; overflow-y: auto;">
            <h2>ü§ù [ ADVANCED TRADING CENTER ]</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <!-- LEFT: CREATE TRADE/GIFT -->
                <div style="border: 3px solid #00ff41; padding: 20px; border-radius: 5px;">
                    <h3 style="color: #00ff41; margin-bottom: 15px;">üì¶ CREATE BUNDLE TRADE</h3>
                    
                    <div style="background: rgba(0,255,65,0.1); padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <label style="display: block; color: #00ff41; font-weight: bold; margin-bottom: 8px;">üéØ Trade With Player:</label>
                        <input type="text" id="tradeToUsername" placeholder="Enter player name" style="width: 100%; padding: 10px; margin-bottom: 10px; background:#111; border:2px solid #00ff41; color:#00ff41; border-radius:3px; font-size: 14px;">
                    </div>

                    <!-- OFFERING SECTION -->
                    <div style="background: rgba(0,255,65,0.15); padding: 12px; border-radius: 5px; margin-bottom: 15px;">
                        <h4 style="color: #00ff41; margin-bottom: 10px;">üì§ YOUR OFFERING:</h4>
                        
                        <label style="display: block; color: #88ff88; font-size: 12px; margin-bottom: 5px;">üí∞ Money:</label>
                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                            <input type="number" id="tradeOfferMoney" placeholder="Amount" min="0" value="0" style="flex:1; padding: 8px; background:#111; border:1px solid #00ff41; color:#00ff41; border-radius:3px;">
                            <button class="btn btn-small" onclick="addMaxMoneyToOffer()" style="width: 60px;">MAX</button>
                        </div>

                        <label style="display: block; color: #88ff88; font-size: 12px; margin-bottom: 5px;">üöÄ Select Ships:</label>
                        <div id="offerShipsList" style="background: #0a0a1e; padding: 10px; border-radius: 3px; max-height: 150px; overflow-y: auto; border: 1px solid #00aa30; margin-bottom: 10px;">
                            <p style="color: #666; font-size: 11px;">No ships unlocked</p>
                        </div>

                        <div id="selectedOfferShips" style="background: rgba(0,255,65,0.2); padding: 8px; border-radius: 3px; margin-bottom: 10px; min-height: 40px; font-size: 11px;">
                            <div style="color: #888;">Selected Ships: None</div>
                        </div>
                    </div>

                    <!-- REQUESTING SECTION -->
                    <div style="background: rgba(78,205,196,0.15); padding: 12px; border-radius: 5px; margin-bottom: 15px;">
                        <h4 style="color: #4ecdc4; margin-bottom: 10px;">üì• YOU'RE REQUESTING:</h4>
                        
                        <label style="display: block; color: #88dddd; font-size: 12px; margin-bottom: 5px;">üí∞ Money:</label>
                        <input type="number" id="tradeRequestMoney" placeholder="Amount" min="0" value="0" style="width: 100%; padding: 8px; margin-bottom: 10px; background:#111; border:1px solid #4ecdc4; color:#4ecdc4; border-radius:3px;">

                        <label style="display: block; color: #88dddd; font-size: 12px; margin-bottom: 5px;">üöÄ Desired Ships (names separated by comma):</label>
                        <input type="text" id="tradeRequestShips" placeholder="e.g. Rapid Fire, Swift, Assassin" style="width: 100%; padding: 8px; background:#111; border:1px solid #4ecdc4; color:#4ecdc4; border-radius:3px; font-size: 11px;">
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button class="btn" style="flex:1; background: rgba(0,255,65,0.3);" onclick="proposeTrade()">‚úÖ PROPOSE TRADE</button>
                        <button class="btn" style="flex:1; background: rgba(255,217,61,0.3); border-color: #ffd93d; color: #ffd93d;" onclick="sendBundleGift()">üéÅ SEND GIFT BUNDLE</button>
                    </div>

                    <div style="background: rgba(255,107,107,0.1); padding: 10px; border-radius: 3px; margin-top: 10px; border: 1px solid #ff6b6b;">
                        <div style="color: #ff6b6b; font-size: 11px;">
                            <strong>‚ö†Ô∏è TRADE RULES:</strong><br>
                            ‚Ä¢ Trade money OR ships or BOTH<br>
                            ‚Ä¢ Can bundle multiple ships<br>
                            ‚Ä¢ Both players must agree<br>
                            ‚Ä¢ Completed instantly
                        </div>
                    </div>
                </div>

                <!-- RIGHT: NOTIFICATIONS & HISTORY -->
                <div style="border: 3px solid #ffd93d; padding: 20px; border-radius: 5px;">
                    <h3 style="color: #ffd93d; margin-bottom: 15px;">üìä YOUR TRADING STATS</h3>
                    
                    <div style="background: rgba(255,217,61,0.1); padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 13px; color: #ffd93d;">
                            <div>üí∞ Money: <span style="font-weight: bold;" id="statMoney">${money}</span></div>
                            <div>‚≠ê Score: <span style="font-weight: bold;" id="statScore">${score}</span></div>
                            <div>üöÄ Ships: <span style="font-weight: bold;" id="shipsCount">0</span></div>
                            <div>üìà Level: <span style="font-weight: bold;">${maxLevel}</span></div>
                            <div>üéÅ Gifts Sent: <span style="font-weight: bold;" id="giftsCount">0</span></div>
                            <div>üì® Gifts Got: <span style="font-weight: bold;" id="receivedCount">0</span></div>
                            <div>‚è≥ Pending: <span style="font-weight: bold;" id="tradesCount">0</span></div>
                            <div>‚úÖ Completed: <span style="font-weight: bold;" id="completedCount">0</span></div>
                        </div>
                    </div>

                    <h4 style="color: #ffd93d; margin-bottom: 10px;">üìú TRADE HISTORY (COMPLETED)</h4>
                    <div id="tradeHistoryList" style="background: #0a0a1e; border: 1px solid #ffd93d; border-radius: 3px; max-height: 250px; overflow-y: auto; padding: 10px;">
                        <p style="color: #666; font-size: 11px;">Loading...</p>
                    </div>
                </div>
            </div>

            <!-- PENDING SECTION -->
            <div style="border: 2px solid #ff00ff; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                <h3 style="color: #ff00ff; margin-bottom: 15px;">‚è≥ PENDING TRADE REQUESTS</h3>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;" id="pendingTradesList">
                    <p style="color: #888;">Loading...</p>
                </div>
            </div>

            <!-- GIFTS SECTION -->
            <div style="border: 2px solid #00ffaa; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                <h3 style="color: #00ffaa; margin-bottom: 15px;">üéÅ RECEIVED GIFTS & BUNDLES</h3>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;" id="receivedGiftsList">
                    <p style="color: #888;">Loading...</p>
                </div>
            </div>

            <button class="close-btn" style="width: 100%;" onclick="closeTrading()">CLOSE TRADING CENTER</button>
        </div>
    `;
    
    document.body.appendChild(modal);
    return modal;
}

async function loadTradingUI() {
    try {
        // Load data from Firebase
        if (firebaseEnabled && db) {
            await loadTradesFromFirebase();
            await loadGiftsFromFirebase();
        }

        // Update your ships list
        const shipsList = document.getElementById('offerShipsList');
        if (Object.keys(unlockedShips).length === 0) {
            shipsList.innerHTML = '<p style="color: #666; font-size: 11px;">No ships</p>';
        } else {
            shipsList.innerHTML = Object.entries(unlockedShips).map(([key, ship]) => `
                <div style="padding: 6px; margin: 3px 0; background: rgba(0,255,65,0.1); border-radius: 3px; display: flex; justify-content: space-between; align-items: center; font-size: 11px;">
                    <span style="color: #00ff41;">üöÄ ${ship.name}</span>
                    <button class="btn btn-small" onclick="toggleShipInOffer('${key}', '${ship.name}')" style="padding: 3px 8px; font-size: 10px;">+ ADD</button>
                </div>
            `).join('');
        }

        // Update stats
        document.getElementById('shipsCount').textContent = Object.keys(unlockedShips).length;
        document.getElementById('giftsCount').textContent = sentGifts.length;
        document.getElementById('receivedCount').textContent = receivedGifts.length;
        document.getElementById('tradesCount').textContent = pendingTrades.filter(t => t.status === 'pending').length;
        document.getElementById('completedCount').textContent = tradeHistory.length;
        document.getElementById('statMoney').textContent = money;
        document.getElementById('statScore').textContent = score;

        // Load trade history
        const historyList = document.getElementById('tradeHistoryList');
        if (tradeHistory.length === 0) {
            historyList.innerHTML = '<p style="color: #666; font-size: 11px;">No completed trades</p>';
        } else {
            historyList.innerHTML = tradeHistory.slice(-10).reverse().map(trade => `
                <div style="background: rgba(255,217,61,0.1); padding: 8px; margin-bottom: 5px; border-radius: 3px; font-size: 10px; border-left: 3px solid #ffd93d;">
                    <div style="color: #ffd93d; font-weight: bold;">${trade.direction === 'sent' ? 'üì§' : 'üì•'} ${trade.withPlayer}</div>
                    ${trade.moneyGiven ? `<div>üí∞ Gave: ${trade.moneyGiven}</div>` : ''}
                    ${trade.moneyReceived ? `<div>üí∞ Got: ${trade.moneyReceived}</div>` : ''}
                    ${trade.shipsGiven && trade.shipsGiven.length ? `<div>üöÄ Gave: ${trade.shipsGiven.join(', ')}</div>` : ''}
                    ${trade.shipsReceived && trade.shipsReceived.length ? `<div>üöÄ Got: ${trade.shipsReceived.join(', ')}</div>` : ''}
                    <div style="color: #666; margin-top: 3px;">‚úÖ ${new Date(trade.timestamp).toLocaleDateString()}</div>
                </div>
            `).join('');
        }

        // Load pending trades
        const pendingList = document.getElementById('pendingTradesList');
        const activePending = pendingTrades.filter(t => t.status === 'pending');
        if (activePending.length === 0) {
            pendingList.innerHTML = '<p style="color: #888;">No pending trades</p>';
        } else {
            pendingList.innerHTML = activePending.map((trade, idx) => {
                const realIndex = pendingTrades.indexOf(trade);
                return `
                    <div style="background: rgba(255,0,255,0.1); border: 2px solid #ff00ff; padding: 12px; border-radius: 5px;">
                        <div style="color: #ff00ff; font-weight: bold; margin-bottom: 10px;">
                            ${trade.direction === 'incoming' ? 'üì• FROM' : 'üì§ TO'}: ${trade.fromPlayer === currentUsername ? trade.toPlayer : trade.fromPlayer}
                        </div>
                        
                        <div style="background: rgba(0,0,0,0.5); padding: 8px; border-radius: 3px; margin-bottom: 10px; font-size: 11px;">
                            <div style="color: #00ff41; margin-bottom: 5px;">üì§ They Offer:</div>
                            ${trade.offeringMoney ? `<div style="margin-left: 10px; color: #88ff88;">üí∞ ${trade.offeringMoney}</div>` : ''}
                            ${trade.offeringShips && trade.offeringShips.length ? `<div style="margin-left: 10px; color: #88ff88;">üöÄ ${trade.offeringShips.join(', ')}</div>` : ''}
                        </div>

                        <div style="background: rgba(0,0,0,0.5); padding: 8px; border-radius: 3px; margin-bottom: 10px; font-size: 11px;">
                            <div style="color: #4ecdc4; margin-bottom: 5px;">üì• Requesting:</div>
                            ${trade.requestingMoney ? `<div style="margin-left: 10px; color: #88dddd;">üí∞ ${trade.requestingMoney}</div>` : ''}
                            ${trade.requestingShips && trade.requestingShips.length ? `<div style="margin-left: 10px; color: #88dddd;">üöÄ ${trade.requestingShips.join(', ')}</div>` : ''}
                        </div>

                        ${trade.direction === 'incoming' ? `
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-small" style="flex:1; background: rgba(0,255,65,0.3);" onclick="acceptTradeOffer(${realIndex})">‚úÖ ACCEPT</button>
                                <button class="btn btn-small" style="flex:1; background: rgba(255,0,0,0.3);" onclick="rejectTradeOffer(${realIndex})">‚ùå REJECT</button>
                            </div>
                        ` : `<div style="color: #888; font-size: 10px; text-align: center; padding: 8px;">‚è≥ Waiting for response...</div>`}
                    </div>
                `;
            }).join('');
        }

        // Load received gifts
        const giftsList = document.getElementById('receivedGiftsList');
        if (receivedGifts.length === 0) {
            giftsList.innerHTML = '<p style="color: #888;">No gifts received</p>';
        } else {
            giftsList.innerHTML = receivedGifts.map((gift, idx) => `
                <div style="background: rgba(0,255,170,0.1); border: 2px solid #00ffaa; padding: 12px; border-radius: 5px;">
                    <div style="color: #00ffaa; font-weight: bold; margin-bottom: 8px;">üéÅ FROM: ${gift.from}</div>
                    ${gift.money ? `<div style="color: #88ff88; margin-bottom: 5px;">üí∞ +${gift.money}</div>` : ''}
                    ${gift.ships && gift.ships.length ? `<div style="color: #88ff88; margin-bottom: 5px;">üöÄ ${gift.ships.join(', ')}</div>` : ''}
                    ${gift.message ? `<div style="color: #888; font-size: 10px; margin-bottom: 8px;">üí¨ "${gift.message}"</div>` : ''}
                    <button class="btn" style="width: 100%; background: rgba(0,255,170,0.3);" onclick="claimGift(${idx})">‚úÖ CLAIM GIFT</button>
                </div>
            `).join('');
        }
    } catch (err) {
        console.error('Error loading trading UI:', err);
    }
}

async function loadTradesFromFirebase() {
    if (!firebaseEnabled || !db) return;
    
    try {
        // Load pending trades
        const pendingSnapshot = await db.collection('trades')
            .where('status', '==', 'pending')
            .get();

        pendingTrades = [];
        pendingSnapshot.forEach(doc => {
            const data = doc.data();
            if (data.fromPlayer === currentUsername || data.toPlayer === currentUsername) {
                pendingTrades.push({
                    ...data,
                    fbId: doc.id,
                    direction: data.toPlayer === currentUsername ? 'incoming' : 'outgoing'
                });
            }
        });

        // Load completed trades
        const completedSnapshot = await db.collection('trades')
            .where('status', '==', 'completed')
            .get();

        tradeHistory = [];
        completedSnapshot.forEach(doc => {
            const data = doc.data();
            if (data.fromPlayer === currentUsername || data.toPlayer === currentUsername) {
                tradeHistory.push({
                    ...data,
                    direction: data.fromPlayer === currentUsername ? 'sent' : 'received',
                    withPlayer: data.fromPlayer === currentUsername ? data.toPlayer : data.fromPlayer
                });
            }
        });

        console.log('‚úÖ Trades loaded from Firebase:', pendingTrades.length, 'pending,', tradeHistory.length, 'completed');
    } catch (err) {
        console.error('‚ùå Error loading trades:', err);
    }
}

async function loadGiftsFromFirebase() {
    if (!firebaseEnabled || !db) return;
    
    try {
        const snapshot = await db.collection('gifts')
            .where('to', '==', currentUsername)
            .get();

        receivedGifts = [];
        snapshot.forEach(doc => {
            const data = doc.data();
            receivedGifts.push({
                ...data,
                fbId: doc.id,
                claimed: data.claimed || false
            });
        });

        // Load sent gifts
        const sentSnapshot = await db.collection('gifts')
            .where('from', '==', currentUsername)
            .get();

        sentGifts = [];
        sentSnapshot.forEach(doc => {
            sentGifts.push(doc.data());
        });

        console.log('‚úÖ Gifts loaded from Firebase:', receivedGifts.length, 'received,', sentGifts.length, 'sent');
    } catch (err) {
        console.error('‚ùå Error loading gifts:', err);
    }
}

let selectedOfferShips = new Map();

function toggleShipInOffer(key, shipName) {
    if (selectedOfferShips.has(key)) {
        selectedOfferShips.delete(key);
    } else {
        selectedOfferShips.set(key, shipName);
    }
    updateSelectedShipsDisplay();
}

function updateSelectedShipsDisplay() {
    const display = document.getElementById('selectedOfferShips');
    if (selectedOfferShips.size === 0) {
        display.innerHTML = '<div style="color: #888;">Selected Ships: None</div>';
    } else {
        const ships = Array.from(selectedOfferShips.values());
        display.innerHTML = `<div style="color: #00ff41;"><strong>Selected Ships:</strong> ${ships.join(', ')}</div>`;
    }
}

function addMaxMoneyToOffer() {
    document.getElementById('tradeOfferMoney').value = money;
}

async function proposeTrade() {
    const targetUser = document.getElementById('tradeToUsername').value.trim();
    const offerMoney = parseInt(document.getElementById('tradeOfferMoney').value) || 0;
    const requestMoney = parseInt(document.getElementById('tradeRequestMoney').value) || 0;
    const requestShipsInput = document.getElementById('tradeRequestShips').value.trim();

    if (!targetUser) {
        showStatus('‚ùå Enter player name');
        return;
    }

    if (targetUser.toLowerCase() === currentUsername.toLowerCase()) {
        showStatus('‚ùå Cannot trade with yourself!');
        return;
    }

    const offeringShips = Array.from(selectedOfferShips.values());

    if (offerMoney === 0 && offeringShips.length === 0) {
        showStatus('‚ùå Offer something (money or ships)!');
        return;
    }

    if (offerMoney > money) {
        showStatus('‚ùå Not enough money to offer!');
        return;
    }

    const requestShips = requestShipsInput ? requestShipsInput.split(',').map(s => s.trim()).filter(s => s) : [];

    if (requestMoney === 0 && requestShips.length === 0) {
        showStatus('‚ùå Request something (money or ships)!');
        return;
    }

    const playerExists = await checkIfPlayerExists(targetUser);
    if (!playerExists) {
        showStatus('‚ùå Player not found');
        return;
    }

    const trade = {
        fromPlayer: currentUsername,
        toPlayer: targetUser,
        offeringMoney: offerMoney,
        offeringShips: offeringShips,
        requestingMoney: requestMoney,
        requestingShips: requestShips,
        status: 'pending',
        createdAt: new Date(),
        id: Math.random().toString(36).substr(2, 9)
    };

    if (firebaseEnabled && db) {
        try {
            const ref = await db.collection('trades').add(trade);
            trade.fbId = ref.id;
            console.log('‚úÖ Trade saved to Firebase:', ref.id);
            showStatus(`üìã Trade proposal sent to ${targetUser}!`);
        } catch (err) {
            console.error('‚ùå Error creating trade:', err);
            showStatus('‚ùå Error creating trade');
            return;
        }
    }

    pendingTrades.push(trade);
    saveProgress();
    
    document.getElementById('tradeToUsername').value = '';
    document.getElementById('tradeOfferMoney').value = '0';
    document.getElementById('tradeRequestMoney').value = '0';
    document.getElementById('tradeRequestShips').value = '';
    selectedOfferShips.clear();
    updateSelectedShipsDisplay();
    
    await loadTradingUI();
}

async function sendBundleGift() {
    const targetUser = document.getElementById('tradeToUsername').value.trim();
    const giftMoney = parseInt(document.getElementById('tradeOfferMoney').value) || 0;
    const giftMessage = prompt('Add a gift message (optional):', '');

    if (!targetUser) {
        showStatus('‚ùå Enter player name');
        return;
    }

    if (targetUser.toLowerCase() === currentUsername.toLowerCase()) {
        showStatus('‚ùå Cannot gift yourself!');
        return;
    }

    const giftShips = Array.from(selectedOfferShips.values());

    if (giftMoney === 0 && giftShips.length === 0) {
        showStatus('‚ùå Select something to gift!');
        return;
    }

    if (giftMoney > money) {
        showStatus('‚ùå Not enough money!');
        return;
    }

    const playerExists = await checkIfPlayerExists(targetUser);
    if (!playerExists) {
        showStatus('‚ùå Player not found');
        return;
    }

    const gift = {
        from: currentUsername,
        to: targetUser,
        money: giftMoney,
        ships: giftShips,
        message: giftMessage || 'No message',
        timestamp: new Date(),
        claimed: false,
        id: Math.random().toString(36).substr(2, 9)
    };

    if (firebaseEnabled && db) {
        try {
            const ref = await db.collection('gifts').add(gift);
            gift.fbId = ref.id;
            console.log('‚úÖ Gift saved to Firebase:', ref.id);
            showStatus(`üéÅ Gift bundle sent to ${targetUser}!`);
        } catch (err) {
            console.error('‚ùå Error sending gift:', err);
            showStatus('‚ùå Error sending gift');
            return;
        }
    }

    money -= giftMoney;
    selectedOfferShips.forEach(shipName => {
        Object.entries(unlockedShips).forEach(([key, ship]) => {
            if (ship.name === shipName) {
                delete unlockedShips[key];
            }
        });
    });

    sentGifts.push(gift);
    updateHUD();
    saveProgress();
    
    document.getElementById('tradeToUsername').value = '';
    document.getElementById('tradeOfferMoney').value = '0';
    selectedOfferShips.clear();
    updateSelectedShipsDisplay();
    
    await loadTradingUI();
}

async function acceptTradeOffer(index) {
    const trade = pendingTrades[index];
    
    if (money < trade.requestingMoney) {
        showStatus('‚ùå Not enough money to complete trade!');
        return;
    }

    // Exchange money
    money -= trade.requestingMoney;
    money += trade.offeringMoney;

    // Add received ships
    if (trade.offeringShips && trade.offeringShips.length) {
        trade.offeringShips.forEach(shipName => {
            for (let key in unlockedShips) {
                if (unlockedShips[key].name === shipName) {
                    const shipCopy = JSON.parse(JSON.stringify(unlockedShips[key]));
                    unlockedShips[`${key}_${Date.now()}`] = shipCopy;
                    break;
                }
            }
        });
    }

    trade.status = 'completed';
    trade.completedAt = new Date();

    // Update Firebase
    if (firebaseEnabled && db && trade.fbId) {
        try {
            await db.collection('trades').doc(trade.fbId).update({
                status: 'completed',
                completedAt: new Date()
            });
            console.log('‚úÖ Trade completed and saved to Firebase');
        } catch (err) {
            console.error('‚ùå Error updating trade:', err);
        }
    }

    tradeHistory.push({
        ...trade,
        direction: 'received',
        withPlayer: trade.fromPlayer,
        moneyReceived: trade.offeringMoney,
        shipsReceived: trade.offeringShips,
        timestamp: new Date()
    });

    pendingTrades.splice(index, 1);
    updateHUD();
    saveProgress();
    showStatus(`‚úÖ Trade completed!`);
    await loadTradingUI();
}

async function rejectTradeOffer(index) {
    const trade = pendingTrades[index];
    
    if (firebaseEnabled && db && trade.fbId) {
        try {
            await db.collection('trades').doc(trade.fbId).update({
                status: 'rejected'
            });
            console.log('‚úÖ Trade rejected and saved to Firebase');
        } catch (err) {
            console.error('‚ùå Error rejecting trade:', err);
        }
    }

    pendingTrades.splice(index, 1);
    showStatus('‚ùå Trade rejected');
    await loadTradingUI();
}

async function claimGift(index) {
    const gift = receivedGifts[index];
    
    if (gift.claimed) {
        showStatus('‚ùå Gift already claimed!');
        return;
    }

    money += gift.money || 0;
    score += Math.floor((gift.money || 0) / 10);
    
    if (gift.ships && gift.ships.length) {
        gift.ships.forEach(shipName => {
            for (let key in unlockedShips) {
                if (unlockedShips[key].name === shipName) {
                    const shipCopy = JSON.parse(JSON.stringify(unlockedShips[key]));
                    unlockedShips[`${key}_${Date.now()}`] = shipCopy;
                    break;
                }
            }
        });
    }

    gift.claimed = true;

    // Update Firebase
    if (firebaseEnabled && db && gift.fbId) {
        try {
            await db.collection('gifts').doc(gift.fbId).update({
                claimed: true,
                claimedAt: new Date()
            });
            console.log('‚úÖ Gift claimed and saved to Firebase');
        } catch (err) {
            console.error('‚ùå Error claiming gift:', err);
        }
    }

    receivedGifts.splice(index, 1);
    updateHUD();
    saveProgress();
    showStatus(`üéÅ Gift claimed! +üí∞${gift.money || 0}`);
    await loadTradingUI();
}

async function checkIfPlayerExists(username) {
    if (firebaseEnabled && db) {
        try {
            const doc = await db.collection('players').doc(username).get();
            return doc.exists;
        } catch (err) {
            console.error('Check player error:', err);
            return false;
        }
    }
    return true;
}

function closeTrading() {
    const modal = document.getElementById('tradingModal');
    if (modal) modal.classList.remove('active');
    gameRunning = true;
}
function startGame() {
  // Instead of setting currentUsername from input, get it from sessionStorage
  currentUsername = sessionStorage.getItem('currentUsername');
  if (!currentUsername) {
    // fallback or redirect if needed
    alert('No user logged in.');
    window.location.href = 'index.html';
    return;
  }
  document.getElementById('username').textContent = currentUsername;
  document.getElementById('finalUsername').textContent = currentUsername;
  // rest of your startGame code...
}
</script>
</body>
</html>
